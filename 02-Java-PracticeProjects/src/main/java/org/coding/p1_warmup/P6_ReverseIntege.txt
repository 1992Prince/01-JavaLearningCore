 For reversing an integer below code will work and covers basic cases like
 ---------------------------------------------------------------------------
 123 -> 321
 -123 -> -321
 120 -> 21

 public int reverse(int x) {
        int reverse = 0;

        int sign = (x < 0) ? -1 : 1;  // store the sign

        x = Math.abs(x); // work with positive value

        while (x > 0) {
            int rem = x % 10;
            reverse = reverse * 10 + rem;
            x = x / 10;
        }

        reverse = reverse * sign;  // restore sign
        System.out.println(reverse);

        return reverse;
 }

 But in leetcode question we need to handle below case also -
 Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

 so for bigger values above code will not work -

 bcoz -

 x = Math.abs(x); // work with positive value

 âš ï¸ Why it fails

 For most negatives (e.g. -123) this works fine.

 But for the edge case x = Integer.MIN_VALUE = -2147483648, Math.abs(x) overflows because 2147483648 is not representable in a signed 32-bit int.
 â†’ It just returns -2147483648 again.
 â†’ Your loop condition while (x > 0) will never run.
 â†’ Wrong result.

 Also, your code doesnâ€™t check for overflow when building reverse.
 Thatâ€™s why 1534236469 gave the wrong output instead of 0.


 âœ… Correct approach (without using long)

 Donâ€™t take absolute value. Just let the loop run on the signed number and check for
 overflow before multiplying:

 public int reverse(int x) {
     int rev = 0;
     while (x != 0) {
         int rem = x % 10;

         // overflow checks
         if (rev > Integer.MAX_VALUE / 10 ||
             (rev == Integer.MAX_VALUE / 10 && rem > 7)) {
             return 0;
         }
         if (rev < Integer.MIN_VALUE / 10 ||
             (rev == Integer.MIN_VALUE / 10 && rem < -8)) {
             return 0;
         }

         rev = rev * 10 + rem;
         x /= 10;
     }
     return rev;
 }


Step-by-step with x = -123

Initial state

x = -123

rev = 0

Iteration 1:

rem = x % 10 = -123 % 10 = -3

rev = 0 * 10 + (-3) = -3

x = -123 / 10 = -12

Iteration 2:

rem = -12 % 10 = -2

rev = -3 * 10 + (-2) = -30 - 2 = -32

x = -12 / 10 = -1

Iteration 3:

rem = -1 % 10 = -1

rev = -32 * 10 + (-1) = -320 - 1 = -321

x = -1 / 10 = 0 â†’ loop ends

Final result

rev = -321 âœ…

ğŸ”‘ Key idea

We never stripped off the sign (no Math.abs).
Instead:

Each % 10 naturally gives the last digit with the correct sign.

Each / 10 shifts the number towards 0 (Javaâ€™s integer division truncates).

The digits are appended in reverse order, while the negative sign propagates automatically.