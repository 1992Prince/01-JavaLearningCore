ðŸ” Binary Search kya hota hai?

https://leetcode.com/problems/binary-search/description/

Binary Search ek efficient technique hai sorted list(array) ke andar kisi value ko dhoondhne ke liye.

Important condition: Array sorted hona chahiye (increasing ya decreasing).

Isme hum list ko bar-bar aadha (half) karte hain, jab tak value mil na jaye.


ðŸ§  Logic (Sochne ka Tarika):

        -> Start aur end pointers set karo.

        -> Beech ka index (mid) nikaalo.

        -> Agar arr[mid] == target ho â†’ mil gaya!

        -> Agar target < arr[mid] ho â†’ left half me search karo.

        -> Agar target > arr[mid] ho â†’ right half me search karo.

        -> Jab tak start <= end, repeat karo.

âœ… Example:

arr = [10, 20, 30, 40, 50, 60]
idx =  0    1   2   3   4   5
target = 40

ðŸ” Step-by-Step Visualization:

Start = 0, End = 5
Mid = (0+5)//2 = 2 â†’ arr[2] = 30

Target 40 > 30 â†’ right half me jao -> start = mid + 1 = 2 + 1 = 3 and end = 5 [matalab agar right me jana hah toh start = mid + 1]

Start = 3, End = 5
Mid = (3+5)//2 = 4 â†’ arr[4] = 50

Target 40 < 50 â†’ left half me jao -> start = 3 and end = mid - 1 = 4 - 1 = 3 [and if left me jana hah toh end = mid - 1]

Start = 3, End = 3
Mid = (3+3)//2 = 3 â†’ arr[3] = 40 âœ…

Mil gaya! Index = 3


aacha remember while writing logic in if condition check if target < nums[mid] or target > nums[mid]
if u go with vice versa then chances might be there that your code can have incorrect logic of reassigining start and end variable

Time Complexity =  O (log n)


Think like below steps
------------------------

Binary Search algorithm

1) inialize start and end pointers and find mid
2) if target > arr[mid] then we need to search RHS i.e. start value will change i.e. start = mid + 1
3) if target < arr[mid] then we need to search LHS i.e. end value will change i.e. end = mid -1
4) here we are chaning values for start and end and so use while loop and keep condition that start <= end

Note - above code will work for non-duplicates and for duplicates we need to refine the logic more. [PENDING]

// In Java:
// 5 % 2  -> gives the remainder (modulus) -> result = 1
// 5 / 2  -> integer division (both operands are int) -> result = 2 (no decimal part)
// Note: If one operand is a float or double, you'll get a decimal result.
//
// In Binary Search:
// To find the middle index, we use integer division:
// mid = (low + high) / 2;
// This ensures 'mid' is an integer index (decimal part is discarded).
